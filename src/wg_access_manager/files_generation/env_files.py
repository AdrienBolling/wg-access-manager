from dataclasses import dataclass
from pathlib import Path
import argparse, hashlib, ipaddress, os, sys, time, textwrap
from wg_access_manager.data.base import Service

HEADER = "# AUTOGENERATED. DO NOT EDIT.\n# Use generate_env_locked.py to regenerate.\n"
MARKER_BEGIN = "# ---- BEGIN LOCKED ----\n"
MARKER_END = "# ---- END LOCKED ----\n"


def ensure_ipv4(ip: str) -> str:
    ipaddress.IPv4Address(ip)
    return ip


def make_payload(service: Service) -> str:
    ts = int(time.time())
    body = f"SERVICE_NAME={service.name}\nSERVICE_IP={ensure_ipv4(service.ip)}\nGENERATED_AT_UNIX={ts}\n"
    return body


def hash_payload(payload: str) -> str:
    # Hash only the key lines, not the header/markers.
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()


def render_file(payload: str) -> str:
    digest = hash_payload(payload)
    return HEADER + MARKER_BEGIN + payload + f"HASH_SHA256={digest}\n" + MARKER_END


def write_atomic(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    tmp = path.with_suffix(path.suffix + ".tmp")
    tmp.write_text(content, encoding="utf-8")
    os.replace(tmp, path)
    # read-only for owner/group, nothing for others (0440)
    try:
        os.chmod(path, 0o440)
    except PermissionError:
        # fallback: at least make it read-only for owner
        os.chmod(path, 0o400)


def current_payload(path: Path) -> tuple[str | None, str | None]:
    if not path.exists():
        return None, None
    txt = path.read_text(encoding="utf-8", errors="replace")
    start = txt.find(MARKER_BEGIN)
    end = txt.find(MARKER_END)
    if start == -1 or end == -1:
        return None, None
    block = txt[start + len(MARKER_BEGIN) : end]
    lines = [l for l in block.splitlines() if l.strip()]
    # Separate HASH from payload
    payload_lines = [l for l in lines if not l.startswith("HASH_SHA256=")]
    hash_lines = [l for l in lines if l.startswith("HASH_SHA256=")]
    payload = "\n".join(payload_lines) + ("\n" if payload_lines else "")
    digest = hash_lines[0].split("=", 1)[1] if hash_lines else None
    return payload, digest


def upsert_env_locked(
    service: Service, force: bool = False, dry_run: bool = False
) -> str:
    target = Path(service.directory).resolve() / ".env.locked"
    new_payload = make_payload(service)
    new_hash = hash_payload(new_payload)
    old_payload, old_hash = current_payload(target)

    if old_payload is not None and old_hash == hash_payload(old_payload):
        # file is intact; decide whether update is needed
        if hash_payload(old_payload) == new_hash and not force:
            return f"[=] {service.name}: up-to-date -> {target}"
        # else: payload changed or force=true â†’ rewrite

    rendered = render_file(new_payload)
    if dry_run:
        return f"[DRY] would write {target}\n" + textwrap.indent(rendered, "      ")
    write_atomic(target, rendered)
    return f"[OK] {service.name}: wrote {target}"
