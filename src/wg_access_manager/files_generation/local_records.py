from dataclasses import dataclass
from pathlib import Path
from typing import Iterable
import ipaddress
import re
from wg_access_manager.data.base import User, Service


@dataclass
class DnsConfig:
    user_suffix: str = "user.vpn"
    service_suffix: str = "srv.vpn"
    root_suffix: str = "vpn"  # pattern alias suffix (name.vpn)
    outfile: Path = Path("./pihole/dnsmasq.d/10-vpn-hosts.conf")
    include_ptr: bool = True
    ttl: int | None = None
    prefer_service_alias: bool = True


LABEL_RE = re.compile(r"^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$")


def sanitize_label(s: str) -> str:
    s = s.strip().lower()
    s = re.sub(r"[^a-z0-9-]", "-", s).strip("-")
    if not s or len(s) > 63 or not LABEL_RE.match(s):
        raise ValueError(f"Invalid DNS label: {s!r}")
    return s


def ensure_ipv4(ip: str) -> str:
    ipaddress.IPv4Address(ip)  # raises if invalid
    return ip


def fqdn_two(left: str, suffix: str) -> str:
    return f"{sanitize_label(left)}.{suffix.strip('.').lower()}"


def ipv4_ptr_name(ip: str) -> str:
    return ".".join(reversed(ip.split("."))) + ".in-addr.arpa"


def make_host_record(name: str, ip: str, ttl: int | None) -> str:
    line = f"host-record={name},{ip}"
    return f"{line},{int(ttl)}" if ttl is not None else line


def make_ptr_record(ip: str, name: str, ttl: int | None) -> str:
    line = f"ptr-record={ipv4_ptr_name(ip)},{name}"
    return f"{line},{int(ttl)}" if ttl is not None else line


def make_cname(alias_fqdn: str, canonical_fqdn: str) -> str:
    return f"cname={alias_fqdn},{canonical_fqdn}"


def generate_records(
    users: Iterable[User], services: Iterable[Service], cfg: DnsConfig
) -> tuple[list[str], list[str]]:
    ttl = cfg.ttl
    lines: list[str] = []
    dups: list[str] = []

    # Canonical maps
    user_canon: dict[str, str] = {}  # base -> fqdn (alice -> alice.user.vpn)
    svc_canon: dict[str, str] = {}  # base -> fqdn (grafana -> grafana.srv.vpn)

    # Emit canonical A/PTR
    def add_canonical(base: str, fqdn: str, ip: str):
        ip = ensure_ipv4(ip)
        lines.append(make_host_record(fqdn, ip, ttl))
        if cfg.include_ptr:
            lines.append(make_ptr_record(ip, fqdn, ttl))

    # Users
    for u in users:
        base = sanitize_label(u.name)
        fq = fqdn_two(base, cfg.user_suffix)
        if base in user_canon and user_canon[base] != fq:
            dups.append(f"user canonical clash for {base}: {user_canon[base]} vs {fq}")
        user_canon.setdefault(base, fq)
        add_canonical(base, fq, u.ip)

    # Services
    for s in services:
        base = sanitize_label(s.name)
        fq = fqdn_two(base, cfg.service_suffix)
        if base in svc_canon and svc_canon[base] != fq:
            dups.append(
                f"service canonical clash for {base}: {svc_canon[base]} vs {fq}"
            )
        svc_canon.setdefault(base, fq)
        add_canonical(base, fq, s.ip)

    # Decide pattern aliases: <base>.vpn  â†’ (service or user canonical)
    alias_target: dict[str, str] = {}  # alias_fqdn -> canonical_fqdn
    for base in set(list(user_canon.keys()) + list(svc_canon.keys())):
        alias_fqdn = fqdn_two(base, cfg.root_suffix)  # e.g., grafana.vpn
        u_fq = user_canon.get(base)
        s_fq = svc_canon.get(base)
        target = s_fq if (cfg.prefer_service_alias and s_fq) else (u_fq or s_fq)
        if not target:
            continue
        prev = alias_target.get(alias_fqdn)
        if prev and prev != target:
            dups.append(f"alias conflict {alias_fqdn}: {prev} vs {target}")
        alias_target[alias_fqdn] = target

    # Emit CNAMEs
    for alias, target in sorted(alias_target.items()):
        lines.append(make_cname(alias, target))

    header = [
        "# Autogenerated local records for Pi-hole/dnsmasq",
        "# Mount into Pi-hole at /etc/dnsmasq.d/10-vpn-hosts.conf and run `pihole restartdns`.",
        "",
    ]
    return header + sorted(set(lines)), sorted(set(dups))


def write_records(outfile: Path, lines: list[str]) -> Path:
    outfile.parent.mkdir(parents=True, exist_ok=True)
    outfile.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return outfile
